package uk.ac.cam.oda22.core.pathfinding.astar;

import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import uk.ac.cam.oda22.core.MathExtended;
import uk.ac.cam.oda22.core.PointInTriangleResult;
import uk.ac.cam.oda22.core.Triangle2D;
import uk.ac.cam.oda22.core.Vector2D;
import uk.ac.cam.oda22.core.environment.Obstacle;
import uk.ac.cam.oda22.core.logging.Log;
import uk.ac.cam.oda22.core.tethers.TetherConfiguration;
import uk.ac.cam.oda22.pathplanning.Path;

/**
 * @author Oliver
 *
 */
public class TetheredAStarPathfinding {

	/**
	 * Performs A* pathfinding from the source to the destination, and returns whether or not a path was found.
	 * The tether needs to be simulated as permanently taut, and must not exceed it's maximum length.
	 * If the tether configuration is undefined then standard tether-less pathfinding will be used.
	 * It is assumed that backtracking along the tether is unnecessary (which is the case if performing path planning).
	 * 
	 * @param source
	 * @param destination
	 * @param nodes
	 * @return shortest valid path
	 */
	public static boolean getShortestPath(AStarGraph g, AStarNode source, AStarNode destination, TetherConfiguration initialTetherConfiguration) {
		//Initialise the nodes.
		for (AStarNode node : g.nodes) {
			node.predecessors = new ArrayList<AStarNode>();
			node.tcs = new ArrayList<TetherConfiguration>();
			node.discovered = false;
			node.g = Double.POSITIVE_INFINITY;
			node.h = node.distance(destination.p);
		}

		// Set the source's g cost to 0, and its only tether configuration to be the initial configuration.
		source.g = 0;
		source.tcs.add(initialTetherConfiguration);

		// Create a queue of the nodes to check neighbours.
		List<AStarNode> q = new LinkedList<AStarNode>();
		q.add(source);

		boolean optimalPathFound = false;

		while (!q.isEmpty() && !optimalPathFound) {
			// Get the lowest cost node and remove it from the queue.
			AStarNode current = getLowestCostNode(q);
			q.remove(current);

			// Stop if a better path cannot be found.
			// Note that we use a strict inequality to allow the possibility of multiple optimal paths.
			if (current.g + current.h > destination.g) {
				optimalPathFound = true;
			}
			else
			{
				// For each undiscovered neighbour of the current edge, try to relax their edge.
				for (AStarEdge edge : current.edges) {
					AStarNode neighbour = (current == edge.p) ? edge.q : edge.p;

					// Relax the edge.
					// Note that we use a non-strict inequality to allow the possibility of multiple equal predecessors.
					if (current.g + edge.cost <= neighbour.g) {
						// TODO: Compute the changes in the tether configuration and verify that it lies within its limits.

						neighbour.predecessors.add(current);

						neighbour.g = current.g + edge.cost;
					}

					// Add the neighbour to the queue if it hasn't been discovered yet.
					if (!neighbour.discovered) {
						q.add(neighbour);

						neighbour.discovered = true;
					}
				}
			}
		}

		return destination.predecessors.size() != 0;
	}

	public static AStarNode getLowestCostNode(List<AStarNode> nodes) {
		AStarNode lowestCostNode = null;
		double lowestH = Double.POSITIVE_INFINITY;

		for (AStarNode node : nodes) {
			if (node.g + node.h < lowestH) {
				lowestCostNode = node;

				lowestH = node.g + node.h;
			}
		}

		return lowestCostNode;
	}

	public static Path retrievePath(AStarNode destination) {
		Path path = new Path();

		List<AStarNode> reversePath = new LinkedList<AStarNode>();

		AStarNode currentNode = destination;

		// Retrieve the reverse path.
		while (currentNode != null) {
			reversePath.add(currentNode);

			if (currentNode.predecessors.size() == 0) {
				currentNode = null;
			}
			else if (currentNode.predecessors.size() == 1) {
				// Return any predecessor, assuming the tether configuration does not affect optimality.
				currentNode = currentNode.predecessors.get(0);
			}
		}

		// Reassemble the forward path.
		for (int i = reversePath.size() - 1; i >= 0; i--) {
			path.addPoint(reversePath.get(i).p);
		}

		return path;
	}

	/**
	 * Computes the change in a tether's configuration as it's endpoint moves directly to a destination point.
	 * Returns null if the tether length has been exceeded.
	 * 
	 * @param tc
	 * @param destination
	 * @return new tether configuration if within length restrictions, null otherwise
	 */
	private static TetherConfiguration computeTetherChange(
			TetherConfiguration tc,
			double maxTetherLength,
			Point2D destination,
			List<Obstacle> obstacles) {
		return null;
	}

	/**
	 * Computes the point at which the tether wraps or unwraps around an obstacle, on its way to point d.
	 * A resultant tether configuration is returned, whose final point may have reached d.
	 * 
	 * @param tc
	 * @param d
	 * @param obstacles
	 * @return next tether configuration
	 */
	private static TetherConfiguration getNextTetherConfiguration(
			TetherConfiguration tc,
			Point2D d,
			List<Obstacle> obstacles) {
		TetherConfiguration newTC = new TetherConfiguration(tc);

		int s = tc.points.size();

		if (s == 0) {
			// If the tether configuration is empty then fail.
			Log.error("Invalid tether configuration (empty).");

			return null;
		}
		else if (s == 1) {
			// TODO:

			// We cannot wrap around an obstacle vertex if we start at the anchor point.
		}
		else if (s == 2) {
			// TODO:

			// We cannot unwrap since there is no tether (segment rq) to unwrap.
		}

		// Get the last point p, penultimate point, q, and previous point, r, on the tether.
		// q and r both define possible wrap and unwrap points.
		// Line q-r lie along an obstacle edge, while line p-q is necessarily in open space for a non-point robot.
		// The last tether segment pivots around q.
		// Note that p is the robot's position and hence the point from which movement starts.
		Point2D p = tc.points.get(s - 1);
		Point2D q = tc.points.get(s - 2);
		Point2D r = tc.points.get(s - 3);

		// Get the vectors p -> d, q -> p, q -> d and r -> q.
		Vector2D pd = new Vector2D(p, d);
		Vector2D qp = new Vector2D(q, p);
		Vector2D qd = new Vector2D(q, d);
		Vector2D rq = new Vector2D(r, q);

		// Get the angle from the penultimate tether point to the current tether point.
		double startAngle = qp.getAngle();

		// Starting at 'pivot point' q, get the change in angle going from p and d.
		double angularChange = MathExtended.getAngularChange(startAngle, qd.getAngle());

		// If the angular change is zero then the tether will not wrap around anything.
		// This assumes that we only make legitimate movements, i.e. the robot's path from p to d is clear of obstacles.
		if (angularChange == 0) {
			// Change the last point on the tether (from p) to d.
			newTC.moveLastPoint(d);
			return newTC;
		}

		// Get the point at which unwrapping would occur along the line pd.
		// This is the intersection point between (directed infinite line) rq and (finite line) pd, if it exists.
		// It is not sufficient to simply compare angles of qp, rq and qd.
		// This point should still be defined if r, q and p are collinear.
		Point2D u = getUnwrapPoint(r, q, rq, p, pd);

		// Create a triangle qpu (if u exists) or qpd (if u does not exist).
		// If an obstacle point lies within this triangle then the tether will wrap around the one closest in angle to qp.
		// For qpu, if no obstacle lies within the triangle then an unwrap will occur.
		// For qpd, if no obstacle lies within the triangle then the robot can proceed straight to d (whilst keeping it's tether taut).
		Triangle2D wrapZone = u != null ? new Triangle2D(q, p, u) : new Triangle2D(q, p, d);

		// Store the minimum angle between line qp and the line from q to an obstacle vertex, as well as the obstacle vertex itself.
		double minAngleToQP = Double.POSITIVE_INFINITY;
		Point2D minVertex = null;

		/*
		 * Note that since rq lie on an obstacle edge, p is necessarily on the side of the obstacle.
		 * If this isn't the case then the tether is not taut.
		 */

		// Check all obstacle vertices for this first wrap point.
		for (Obstacle o : obstacles) {
			for (Point2D v : o.points) {
				// Check if the neighbouring points of v do not prevent the wrapping of the tether.
				// This is used to take care of cases where q, p and v are collinear, or q is collinear with v and one of its neighbouring vertices.
				boolean canWrap = isWrappingPossible(q, p, qp, qd, v, o);

				// Check if the vertex lies within the wrap zone.
				boolean inWrapZone = wrapZone.containsPoint(v) != PointInTriangleResult.NONE;

				// If the vertex is valid from wrapping, and lies within the wrap zone, then check if it has the smallest angle to qp.
				if (canWrap && inWrapZone) {
					// Get the vector from q to the obstacle vertex.
					Vector2D qv = new Vector2D(q, v);

					// Use the magnitude of the angle, since d (and thus v) could be on either side of qp.
					double angleToQP = Math.abs(MathExtended.getAngularChange(startAngle, qv.getAngle()));

					if (angleToQP < minAngleToQP) {
						minAngleToQP = angleToQP;
						minVertex = v;
					}
					else if (angleToQP == minAngleToQP) {
						// Given that the angular changes are equal, the point closer to p should be chosen.
						// This means that there will be no wrapping around the point closer to q.
						if (v.distance(p) < minVertex.distance(p)) {
							minAngleToQP = angleToQP;
							minVertex = v;
						}
					}
				}
			}
		}

		// If the tether will wrap around a point, then alter the tether configuration accordingly.
		if (minVertex != null) {
			Vector2D qv = new Vector2D(q, minVertex);

			// Get the extended intersection point between lines qv (v is minVertex) and pd.
			// Note that this intersection point would necessarily lie on the finite line pd.
			Point2D newP = MathExtended.getExtendedIntersectionPoint(q, qv, p, pd);

			// Remove the last point on the tether (p) and add the new vertices, minVertex and newP.
			newTC.removePoint();
			newTC.addPoint(minVertex);
			newTC.addPoint(newP);
			return newTC;
		}

		// If an unwrap point exists then unwrap, and alter the tether configuration accordingly.
		if (u != null) {
			// Change the last point on the tether (from p) to u.
			newTC.moveLastPoint(u);
			return newTC;
		}
		
		// Since we cannot wrap nor unwrap, move straight to d, and alter the tether configuration accordingly.
		// Change the last point on the tether (from p) to u.
		newTC.moveLastPoint(u);
		return newTC;
	}

	/**
	 * Gets the point at which the tether would start unwrapping around an obstacle.
	 * Unwrapping would occur at point q, the penultimate tether vertex.
	 * Point r is the point on the tether that precedes q.
	 * Point p is the robot's position, and d is the destination.
	 * This computes the intersection between the directed infinite line starting at r going through q, and finite line pd.
	 * 
	 * @param r
	 * @param q
	 * @param rq
	 * @param p
	 * @param pd
	 * @return valid intersection point, null otherwise
	 */
	private static Point2D getUnwrapPoint(Point2D r, Point2D q, Vector2D rq, Point2D p, Vector2D pd) {
		// Get the extended intersection point between rq and pd.
		Point2D u = MathExtended.getExtendedIntersectionPoint(r, rq, p, pd);

		// Get the equivalent line for pd.
		Line2D pdLine = MathExtended.getLine(p, pd);

		// Fail if u is not on the finite line pd.
		if (!MathExtended.loosePointOnLine(u, pdLine)) {
			return null;
		}

		// Fail if u is closer to r than q.
		// If this is the case then travelling to d will cause the tether to fully wrap around the obstacle with edge rq.
		// Note that this does not necessarily mean that the tether will cross.
		if (u.distance(r) < u.distance(q)) {
			return null;
		}

		return u;
	}

	/**
	 * Returns whether or not a tether segment qp can wrap around vertex v given the orientation of its two associated obstacle edges.
	 * This only checks angular values, and does not consider whether or not the tether is long enough.
	 * This does not consider the tether rotating more than 180 degrees.
	 * 
	 * @param q
	 * @param p
	 * @param qp
	 * @param qd
	 * @param v
	 * @param o
	 * @return true if the tether can wrap, false otherwise
	 */
	private static boolean isWrappingPossible(Point2D q, Point2D p, Vector2D qp, Vector2D qd, Point2D v, Obstacle o) {
		// Fail if the obstacle and/or its vertex is invalid.
		if (v == null || o.points.size() == 0) {
			Log.error("Invalid obstacle.");

			return false;
		}

		// If point v is the only point in the obstacle then the tether can wrap around it.
		if (o.points.size() == 1) {
			return true;
		}

		// If q and v or p and v are the same point then the tether cannot wrap point v.
		if (q.equals(v) || p.equals(v)) {
			return false;
		}

		// Get the direction in which the tether will rotate.
		boolean clockwise = isTetherMovementClockwise(qp, qd);

		// Get the previous and next vertices in the obstacle.
		Point2D u = o.getPreviousVertex(v);
		Point2D w = o.getNextVertex(v);

		// If the current robot position (p) is the same point as either neighbouring obstacle vertex then the tether cannot wrap around point v.
		if (p.equals(u) || p.equals(w)) {
			return false;
		}

		// Get the vectors from q to the obstacle vertices.
		Vector2D qv = new Vector2D(q, v);
		Vector2D qu = new Vector2D(q, u);
		Vector2D qw = new Vector2D(q, w);

		// Get the angular changes between qp and the three vectors from q to each obstacle vertex.
		double aQPV = MathExtended.getAngularChange(qp, qv);
		double aQPU = MathExtended.getAngularChange(qp, qu);
		double aQPW = MathExtended.getAngularChange(qp, qw);

		// If any obstacle vertex is on the wrong side (opposite side to tether rotation), then the tether cannot wrap around v.
		// This means that we only consider up to half a revolution of tether rotation.
		if ((clockwise && (aQPV > 0 || aQPU > 0 || aQPW > 0))
				|| (!clockwise && (aQPV < 0 || aQPU < 0 || aQPW < 0))) {
			return false;
		}


		// If v is collinear with q and either neighbouring obstacle vertex, x, then x must lie no farther away from q than v does.
		if ((aQPV == aQPU && u.distance(q) > v.distance(q))
				|| (aQPV == aQPW && w.distance(q) > v.distance(q))) {
			return false;
		}

		// Check if the angle from q to v is closer than that to u and w in comparison to qp.
		// Note that this method is still valid for obstacles with two vertices (i.e. vPrev and vNext are the same).
		if (clockwise) {
			// If either neighbouring obstacle vertex, x, and q are distinct then the angle from q to v must be less negative than that to x.
			if ((!u.equals(q) && aQPV > aQPU)
					|| (!w.equals(q) && aQPV > aQPW)) {
				return false;
			}
		}
		else {
			// If either neighbouring obstacle vertex, x, and q are distinct then the angle from q to v must be less positive than that to x.
			if ((!u.equals(q) && aQPV < aQPU)
					|| (!w.equals(q) && aQPV < aQPW)) {
				return false;
			}
		}

		return true;
	}

	private static boolean isTetherMovementClockwise(Vector2D qp, Vector2D qd) {
		return MathExtended.getAngularChange(qp.getAngle(), qd.getAngle()) < 0;
	}

}
