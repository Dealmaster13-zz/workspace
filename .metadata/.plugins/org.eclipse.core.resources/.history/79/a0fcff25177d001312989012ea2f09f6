package uk.ac.cam.oda22.core;

import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.util.List;

import uk.ac.cam.oda22.pathplanning.Path;

/**
 * @author Oliver
 *
 */
public final class MathExtended {

	public static boolean ApproxEqual(double m, double n, double fractionalError, double absoluteError) {
		if (Math.abs(n - m) <= absoluteError) {
			return true;
		}

		if (m != 0 && n != 0) {
			return Math.abs(1 - (m / n)) <= fractionalError;
		}

		return false;
	}

	public static boolean ApproxEqual(Point2D p, Point2D q, double fractionalError, double absoluteError) {
		return ApproxEqual(p.getX(), q.getX(), fractionalError, absoluteError)
				&& ApproxEqual(p.getY(), q.getY(), fractionalError, absoluteError);
	}

	public static boolean ApproxEqual(Line2D l, Line2D m, double fractionalError, double absoluteError) {
		if (ApproxEqual(l.getP1(), m.getP1(), fractionalError, absoluteError)
				&& ApproxEqual(l.getP2(), m.getP2(), fractionalError, absoluteError)) {
			return true;
		}

		if (ApproxEqual(l.getP1(), m.getP2(), fractionalError, absoluteError)
				&& ApproxEqual(l.getP2(), m.getP1(), fractionalError, absoluteError)) {
			return true;
		}

		return false;
	}

	public static double getRadius(double w, double h) {
		return Math.sqrt((w * w) + (h * h));
	}

	/**
	 * Gets the shortest angular change from one angle to another.
	 * 
	 * @param radsFrom
	 * @param radsTo
	 * @return angular change
	 */
	public static double getAngularChange(double radsFrom, double radsTo) {
		return normaliseAngle(radsTo - radsFrom);
	}

	/**
	 * Normalises an angle to take a value between -pi and +pi.
	 * 
	 * @param rads
	 * @return normalised angle
	 */
	public static double normaliseAngle(double rads) {
		double twoPi = 2 * Math.PI;

		double normalisedAngle = rads % twoPi;

		normalisedAngle = (normalisedAngle + twoPi) % twoPi;

		if (normalisedAngle > Math.PI) {
			normalisedAngle -= twoPi;
		}

		return normalisedAngle;
	}

	/**
	 * Checks if 'a' lies between r1 and r2, where r1 and r2 are unordered.
	 * 
	 * @param a
	 * @param r1
	 * @param r2
	 * @return true if 'a' lies between r1 and r2, and false otherwise
	 */
	public static boolean inRange(double a, double r1, double r2, boolean strictInequality) {
		double min = Math.min(r1, r2);
		double max = Math.max(r1, r2);

		if (strictInequality) {
			return a > min && a < max;
		}
		else {
			return a >= min && a <= max;
		}
	}

	public static PointOnLineResult pointOnLine(Point2D p, Line2D l) {
		// Check if the point does not lie on the line.
		if (!l.contains(p)) {
			return PointOnLineResult.NONE;
		}

		// Check if the point is at the first endpoint.
		if (p.getX() == l.getX1() && p.getY() == l.getY1()) {
			return PointOnLineResult.AT_ENDPOINT;
		}

		// Check if the point is at the second endpoint.
		if (p.getX() == l.getX2() && p.getY() == l.getY2()) {
			return PointOnLineResult.AT_ENDPOINT;
		}

		return PointOnLineResult.WITHIN_LINE;
	}

	public static boolean colinear(Line2D l1, Line2D l2) {
		int i = 0;

		if (pointOnLine(l1.getP1(), l2) != PointOnLineResult.NONE) {
			i ++;
		}

		if (pointOnLine(l1.getP2(), l2) != PointOnLineResult.NONE) {
			i ++;
		}

		if (pointOnLine(l2.getP1(), l1) != PointOnLineResult.NONE) {
			i ++;
		}

		if (pointOnLine(l2.getP2(), l1) != PointOnLineResult.NONE) {
			i ++;
		}

		// Return true if at least two endpoints lie on the other line.
		return i >= 2;
	}

	public static LineIntersectionResult intersectsLine(Line2D l1, Line2D l2) {
		// Check if the lines do not intersect.
		if (!l1.intersectsLine(l2)) {
			return LineIntersectionResult.NONE;
		}

		// Check if the lines are colinear.
		if (colinear(l1, l2)) {
			return LineIntersectionResult.COLINEAR;
		}

		// Check if the an endpoint of one line lies on the other line.
		PointOnLineResult r1 = pointOnLine(l1.getP1(), l2);
		PointOnLineResult r2 = pointOnLine(l1.getP2(), l2);
		PointOnLineResult r3 = pointOnLine(l2.getP1(), l1);
		PointOnLineResult r4 = pointOnLine(l2.getP2(), l1);

		if (r1 == PointOnLineResult.AT_ENDPOINT
				|| r2 == PointOnLineResult.AT_ENDPOINT
				|| r3 == PointOnLineResult.AT_ENDPOINT
				|| r4 == PointOnLineResult.AT_ENDPOINT) {
			return LineIntersectionResult.JOINT;
		}
		else if (r1 == PointOnLineResult.WITHIN_LINE
				|| r2 == PointOnLineResult.WITHIN_LINE
				|| r3 == PointOnLineResult.WITHIN_LINE
				|| r4 == PointOnLineResult.WITHIN_LINE) {
			return LineIntersectionResult.A_TOUCHES_B;
		}

		return LineIntersectionResult.CROSS;
	}

	public static boolean strictIntersectsLine(Line2D l1, Line2D l2) {
		return intersectsLine(l1, l2) == LineIntersectionResult.CROSS;
	}

	public static boolean strictPathIntersectsLine(Path p, Line2D l) {
		List<Line2D> pathEdges = p.getEdges();

		if (pathEdges.size() == 0) {
			return false;
		}

		// For each path segment, check if it intersects with the line. 
		for (int i = 0; i < pathEdges.size(); i++) {
			if (strictIntersectsLine(pathEdges.get(i), l)) {
				return true;
			}

			// Check if the line crosses a joint in the path.
			// Check if the second endpoint of the current path segment lies within the line.
			if (i != pathEdges.size() - 1) {
				Point2D endpoint = pathEdges.get(i).getP2();
				
				PointOnLineResult r = pointOnLine(endpoint, l);

				if (r == PointOnLineResult.WITHIN_LINE) {
					return true;
				}
			}
		}

		return false;
	}

	public static boolean strictPathIntersectsPath(Path p1, Path p2) {
		List<Line2D> p2Edges = p2.getEdges();

		for (int i = 0; i < p2Edges.size(); i++) {
			if (strictPathIntersectsLine(p1, p2Edges.get(i))) {
				return true;
			}
		}

		return false;
	}

	public static boolean isPointOnLine(Point2D p, Line2D l) {
		return l.contains(p);

		/*// Calculate the gradient of the line.
		double g = (l.getY2() - l.getY1()) / (l.getX2() - l.getX1());

		// Calculate the y value for the point given its x value if it were on the line.
		double y = l.getY1() + (g * (p.getX() - l.getX1()));

		// Check if the point is on the line.
		if (MathExtended.ApproxEqual(y, p.getY(), 0.0001, 0.0001)) {
			// Fail if the point is outside of the line's bounds.
			if (!l.getBounds().contains(p))
			{
				return false;
			}

			return true;
		}

		return false;*/
	}

	public static Point2D getCartesian(double radius, double rads) {
		double x = radius * Math.cos(rads);
		double y = radius * Math.sin(rads);

		return new Point2D.Double(x, y);
	}

	/**
	 * Translates point p by position vector t, returning a new point.
	 * 
	 * @param p
	 * @param t
	 * @return translated point
	 */
	public static Point2D translate(Point2D p, Point2D t) {
		return new Point2D.Double(p.getX() + t.getX(), p.getY() + t.getY());
	}

}
