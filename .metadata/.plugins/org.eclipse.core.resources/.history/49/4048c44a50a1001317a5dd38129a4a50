package uk.ac.cam.oda22.coverage.simple;

/**
 * @author Oliver
 * 
 */
public class SimpleCoverageRouteNode implements
		Comparable<SimpleCoverageRouteNode> {

	/**
	 * The room cell index of the node.
	 */
	public final RoomCellIndex index;

	/**
	 * The node which comes before this node.
	 */
	public final SimpleCoverageRouteNode previousNode;

	/**
	 * The length of the path.
	 */
	public final int pathLength;

	/**
	 * The re-coverage count which corresponds to the previous node list.
	 */
	public final int recoverageCount;

	/**
	 * The status of whether or not the robot is re-covering tiles at this
	 * stage.
	 */
	public final boolean recovering;

	public SimpleCoverageRouteNode(RoomCellIndex index,
			SimpleCoverageRouteNode previousNode) {
		this.index = index;
		this.previousNode = previousNode;

		this.pathLength = previousNode != null ? previousNode.pathLength : 0;

		// Get the re-coverage count of the previous node.
		int previousRecoverageCount = previousNode != null ? previousNode.recoverageCount
				: 0;

		// Check if this node has already been visited.
		this.recovering = isRevisited(this.index, this.previousNode);

		// Increment the recoverage count if the node has been revisited.
		this.recoverageCount = previousRecoverageCount
				+ (this.recovering ? 1 : 0);
	}

	private static boolean isRevisited(RoomCellIndex index,
			SimpleCoverageRouteNode previousNode) {
		SimpleCoverageRouteNode n = previousNode;

		while (n != null) {
			if (n.index.equals(index)) {
				return true;
			}
		}

		return false;
	}

	@Override
	public int compareTo(SimpleCoverageRouteNode n) {
		// This node has higher value if it has a higher re-coverage count. Note
		// that lower is better in terms of prioritising which node to search
		// next.
		if (this.recoverageCount > n.recoverageCount) {
			return 1;
		} else if (this.recoverageCount < n.recoverageCount) {
			return -1;
		}

		// When the re-coverage counts are equal, compare against the total
		// number of cells covered. Note that the number of unique cells covered
		// is just the total number of cells minus the re-coverage count.
		Integer pl1 = this.pathLength;
		Integer pl2 = n.pathLength;
		return pl1.compareTo(pl2);
	}
}
