package uk.ac.cam.oda22.pathplanning;

import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import uk.ac.cam.oda22.core.ListFunctions;
import uk.ac.cam.oda22.core.MathExtended;
import uk.ac.cam.oda22.core.environment.Obstacle;
import uk.ac.cam.oda22.core.environment.Room;
import uk.ac.cam.oda22.core.environment.VisibilityGraph;
import uk.ac.cam.oda22.core.environment.VisibilityGraphNode;
import uk.ac.cam.oda22.core.logging.Log;
import uk.ac.cam.oda22.core.pathfinding.astar.AStarGraph;
import uk.ac.cam.oda22.core.pathfinding.astar.AStarNode;
import uk.ac.cam.oda22.core.pathfinding.astar.TetheredAStarPathfinding;
import uk.ac.cam.oda22.core.pathfinding.astar.TetheredAStarShortestPathResult;
import uk.ac.cam.oda22.core.pathfinding.astar.TetheredAStarSinglePathResult;
import uk.ac.cam.oda22.core.robots.Robot;
import uk.ac.cam.oda22.core.robots.actions.IRobotAction;
import uk.ac.cam.oda22.core.robots.actions.MoveAction;
import uk.ac.cam.oda22.core.robots.actions.RotateAction;
import uk.ac.cam.oda22.core.tethers.ITetherSegment;
import uk.ac.cam.oda22.core.tethers.SimpleTether;
import uk.ac.cam.oda22.core.tethers.SimpleTetherSegment;
import uk.ac.cam.oda22.core.tethers.Tether;
import uk.ac.cam.oda22.core.tethers.TetherConfiguration;
import uk.ac.cam.oda22.core.tethers.TetherPoint;

/**
 * @author Oliver
 * 
 */
public final class PathPlanner {

	public static PathPlanningResult performPathPlanning(Room room,
			Robot robot, Point2D goal, int tetherSegments) {
		/*
		 * Note that Step 1 (triangulate the environment) is carried out by
		 * default in the Room class. Note that Step 2 (compute the visibility
		 * graph) is carried out by default in the Room class.
		 */

		// Expand all of the obstacles.
		// //List<Obstacle> expandedObstacles =
		// room.getExpandedObstacles(robot.radius);

		/*
		 * TODO: Also check if the robot can reach the goal despite its size.
		 */

		// Fail if the goal is not in empty space.
		if (!room.isPointInEmptySpace(goal)) {
			Log.error("Goal (" + goal.getX() + ", " + goal.getY()
					+ ") is not reachable.");

			return null;
		}

		/*
		 * TODO: Fail if the robot in not in empty space.
		 */

		VisibilityGraph visibilityGraph = generateVisibilityGraph(room.obstacles);

		// Add the goal node to the visibility graph.
		visibilityGraph.addNode(goal);

		Point2D startNode = robot.getPosition();

		/*
		 * Step 3: Find the vertices visible from the start position and order
		 * them by their angle relative to s.
		 */
		List<VisibilityGraphNode> l = visibilityGraph
				.getVisibleNodes(startNode);
		sortNodesByAngle(startNode, l);

		/*
		 * Step 4: Compute the changes that occur in the visible vertices of the
		 * reverse path.
		 */
		List<TetherPointVisibility> visibility = getTetherPointVisibilitySets(
				robot.tether, tetherSegments, room, visibilityGraph);

		/*
		 * Step 5: Compute the optimal distance to backtrack and then proceed to
		 * the goal via the shortest path.
		 */
		List<VisibilityChangeList> vList = calculateVisibilitySetChanges(visibility);
		TetheredPath optimalPath = computeOptimalPath(vList, robot.tether, room,
				visibilityGraph, goal, robot.radius);

		// Generate the robot actions which are required to be executed given
		// the optimal path.
		List<IRobotAction> actions = generateActionsFromPath(optimalPath.path,
				robot.getRotation(), robot.rotationalSensitivity);

		return new PathPlanningResult(actions, optimalPath);
	}

	public static PathPlanningResult returnToBase() {
		// TODO: Extension task: implement this method.

		return null;
	}

	/**
	 * Generates the visibility graph.
	 * 
	 * @return the visibility graph
	 */
	private static VisibilityGraph generateVisibilityGraph(
			List<Obstacle> obstacles) {
		VisibilityGraph g = new VisibilityGraph();

		// Add all of the obstacles which also adds the relevant points and
		// edges of the visibility graph.
		for (Obstacle o : obstacles) {
			g.addObstacle(o, true);
		}

		return g;
	}

	/**
	 * Step 3 (second half). Sorts the neighbouring nodes of a particular start
	 * node by their angle relative to the start node.
	 * 
	 * @param startNode
	 * @param neighbours
	 */
	private static void sortNodesByAngle(Point2D startNode,
			List<VisibilityGraphNode> neighbours) {
		List<Double> angles = new ArrayList<Double>();

		for (int i = 0; i < neighbours.size(); i++) {
			Point2D p = neighbours.get(i).p;

			double angle = Math.atan2(startNode.getY() - p.getY(),
					startNode.getX() - p.getX());

			angles.add(angle);
		}

		List<VisibilityGraphNode> sortedNeighbours = new ArrayList<VisibilityGraphNode>();

		for (int i = angles.size() - 1; i >= 0; i--) {
			double min = Double.MAX_VALUE;
			int minIndex = -1;

			for (int j = 0; j < angles.size(); j++) {
				if (angles.get(j) < min) {
					min = angles.get(j);
					minIndex = j;
				}
			}

			sortedNeighbours.add(neighbours.get(minIndex));
			angles.set(minIndex, Double.MAX_VALUE);
		}

		neighbours = sortedNeighbours;
	}

	/**
	 * Step 4. Computes which vertices are visible from different points on the
	 * tether, from the robot to the anchor point. TODO: Replace algorithm with
	 * continuous solution.
	 * 
	 * @param t
	 * @param tetherSegments
	 * @param visibilityGraph
	 * @return tether point visibility sets
	 */
	private static List<TetherPointVisibility> getTetherPointVisibilitySets(
			Tether t, int tetherSegments, Room room,
			VisibilityGraph visibilityGraph) {
		List<TetherPointVisibility> tetherPointVisibilitySets = new LinkedList<TetherPointVisibility>();

		double l = t.getUsedLength();

		double interval = l / tetherSegments;

		// w is the distance along the tether from the robot to the anchor
		// point.
		double w = 0;

		boolean complete = false;

		// Compute the visible vertices from equally spaced points on the
		// tether.
		while (!complete) {
			// Get the position starting from the robot, so use the reverse
			// distance.
			Point2D p = t.getPositionByDistance(l - w);

			if (p == null) {
				Log.error("Tether point is undefined.");

				return null;
			}

			// Compute the visible nodes.
			List<VisibilityGraphNode> visibleNodes = visibilityGraph
					.getVisibleNodes(p);

			List<Point2D> visibleVertices = new ArrayList<Point2D>();

			// Store the vertices from the nodes.
			for (VisibilityGraphNode node : visibleNodes) {
				visibleVertices.add(node.p);
			}

			double nextW = w + interval;

			// Ensure that the last sample point is always at the anchor point.
			if (nextW >= l - (interval / 2)) {
				nextW = l;
			}

			List<TetherPoint> pList = new ArrayList<TetherPoint>();
			pList.add(new TetherPoint(p, w));

			tetherPointVisibilitySets.add(new TetherPointVisibility(w, nextW,
					pList, visibleVertices));

			// Finish once the whole tether has been analysed.
			if (w >= l) {
				complete = true;

				if (w > l) {
					Log.error("Tether position is out of range.");
				}
			} else {
				w = nextW;
			}
		}

		// Merge any duplicate sets.
		mergeDuplicateVisibilitySets(tetherPointVisibilitySets);

		return tetherPointVisibilitySets;
	}

	/**
	 * Step 4 (second half). Merges the visibility sets.
	 * 
	 * @param sets
	 */
	private static void mergeDuplicateVisibilitySets(
			List<TetherPointVisibility> sets) {
		// Iterate backwards over the list of sets, merging any duplicates
		// containing the same visibility set as the previous element.
		for (int i = sets.size() - 2; i >= 0; i--) {
			TetherPointVisibility previous = sets.get(i + 1);
			TetherPointVisibility current = sets.get(i);

			// Merge the sets if they contain the same vertices.
			if (current.isVisibilitySetEqual(previous.visibleVertices)) {
				previous.tetherPoints.addAll(current.tetherPoints);

				sets.remove(current);
			}
		}
	}

	/**
	 * Step 5a. Calculates the changes in the visibility sets.
	 * 
	 * @param s
	 */
	private static List<VisibilityChangeList> calculateVisibilitySetChanges(
			List<TetherPointVisibility> s) {
		List<VisibilityChangeList> v = new ArrayList<VisibilityChangeList>();

		// Keep all visible vertices for the first section.
		List<Point2D> visibleVertices = new ArrayList<Point2D>();
		List<Point2D> vs = s.get(0).visibleVertices;

		for (int i = 0; i < vs.size(); i++) {
			visibleVertices.add(vs.get(i));
		}

		VisibilityChangeList v_0 = new VisibilityChangeList(visibleVertices,
				s.get(0).tetherPoints);

		v.add(v_0);

		// For each section of unchanging visible vertices, compute the set of
		// vertices containing each visible vertex which was not visible in the
		// previous section.
		for (int i = 1; i < s.size(); i++) {
			List<Point2D> previousVertices = s.get(i - 1).visibleVertices;
			List<Point2D> currentVertices = s.get(i).visibleVertices;

			List<Point2D> changes = new ArrayList<Point2D>();

			// Add each point which was not in the previous visibility set.
			for (int j = 0; j < currentVertices.size(); j++) {
				Point2D vertex = currentVertices.get(j);

				if (!ListFunctions.isPointInList(vertex, previousVertices)) {
					changes.add(vertex);
				}
			}

			VisibilityChangeList v_i = new VisibilityChangeList(changes,
					s.get(i).tetherPoints);

			v.add(v_i);
		}

		return v;
	}

	/**
	 * Step 5b. Computes the optimal path using the visibility change lists.
	 * 
	 * @param v
	 * @param t
	 * @param room
	 * @param visibilityGraph
	 * @param goal
	 * @param robotRadius
	 * @return
	 */
	private static TetheredPath computeOptimalPath(List<VisibilityChangeList> v,
			Tether t, Room room, VisibilityGraph visibilityGraph, Point2D goal,
			double robotRadius) {
		Path optimalPath = null;
		Path currentPath;
		
		TetherConfiguration optimalTC = null;

		double tetherUsedLength = t.getUsedLength();

		// For each vertex list in the visibility change list.
		for (int i = 0; i < v.size(); i++) {
			VisibilityChangeList v_i = v.get(i);

			// For each visible vertex.
			for (int j = 0; j < v_i.vertices.size(); j++) {
				currentPath = new Path();

				// Get the visible vertex.
				Point2D vertex = v_i.vertices.get(j);

				// Get the point closest to the robot, along the tether, in this
				// visibility change section.
				TetherPoint x = v_i.getClosestPoint(true);

				/*
				 * Step 5bi and step 5bii.
				 */

				// Get the portion of the tether which should be kept as is,
				// i.e. from the anchor point to x.
				// Note that x.w is a reverse distance, so we subtract it from
				// the tether length.
				double tetherSegmentDistance = tetherUsedLength - x.w;
				TetherConfiguration tetherConfiguration = getTetherConfigurationSegment(
						t, 0, tetherSegmentDistance, x);

				// Calculate the updated configuration having travelled to
				// vertex.
				tetherConfiguration = TetheredAStarPathfinding
						.getNextTetherConfiguration(tetherConfiguration,
								vertex, room.obstacles);

				// Compute the shortest paths from vertex to the goal.
				TetheredAStarShortestPathResult shortestPaths = getShortestPaths(
						vertex, goal, visibilityGraph, tetherConfiguration,
						t.length, robotRadius);

				// Fail if no shortest path was found.
				if (shortestPaths == null
						|| shortestPaths.shortestPathResults.size() == 0) {
					Log.error("The shortest path from v to the goal was not found.");

					return null;
				}

				// Take an arbitrary shortest path and tether configuration - in
				// this case the first one.
				// Note that q-bar is the new tether configuration.
				TetheredAStarSinglePathResult shortestPath = shortestPaths.shortestPathResults
						.get(0);
				Path vToG = shortestPath.path;
				TetherConfiguration newTC = shortestPath.tetherConfiguration;

				// Fail if the path is null, empty, or does not reach the goal.
				if (vToG == null || vToG.isEmpty()
						|| !ListFunctions.getLast(vToG.points).equals(goal)) {
					Log.error("The shortest path from v to the goal was not found.");

					return null;
				}

				// Fail if the path does not contain vertex.
				if (!vToG.contains(vertex)) {
					Log.error("The shortest path from v to the goal does not contain v.");

					return null;
				}

				boolean tetherLengthExceeded = newTC.lengthExceeded(t.length,
						0.0001, 0.0001);

				boolean tetherCrossed = MathExtended
						.strictPathIntersectsItself(newTC);

				// TODO: Set the new tether configuration.

				/*
				 * Step 5biii - skip if the tether length exceeds its limit, or
				 * if the tether is crossed.
				 */

				if (!tetherLengthExceeded && !tetherCrossed) {
					/*
					 * Step 5biv and step 5bv.
					 */

					currentPath = new Path();

					Path forwardTetherSegmentPath;

					if (t instanceof SimpleTether) {
						SimpleTether tether = (SimpleTether) t;

						SimpleTetherSegment tetherSegment = (SimpleTetherSegment) tether
								.getTetherSegment(tetherSegmentDistance,
										tetherUsedLength);

						// Ensure that the tether segment starts at the correct
						// position.
						if (!MathExtended.approxEqual(x.x,
								tetherSegment.path.points.get(0), 0.00001,
								0.00001)) {
							Log.error("Malformed tether segment.");

							return null;
						}

						forwardTetherSegmentPath = tetherSegment.path;
					} else {
						Log.error("Unsupported tether type.");

						return null;
					}

					Path reversePath = forwardTetherSegmentPath.reverse();

					// The path is the reverse tether segment from the robot to
					// tether point x, concatenated with the direct path from x
					// to vertex, concatenated with the
					// shortest path from vertex to the goal.
					// Note that vertex is contained in vToG.
					currentPath.addPoints(reversePath.points);
					currentPath.addPoints(vToG.points);

					// If the current path length is the shortest found so far,
					// then set the optimal path to this new path.
					if (optimalPath == null
							|| currentPath.length() < optimalPath.length()) {
						optimalPath = currentPath;
					}
				}
			}
		}

		return optimalPath;
	}
	
	/**
	 * Helper function for step 5bi, to get a tether segment as a tether
	 * configuration.
	 * 
	 * @param t
	 * @param startW
	 * @param endW
	 * @param x
	 * @return tether configuration
	 */
	private static TetherConfiguration getTetherConfigurationSegment(Tether t,
			double startW, double endW, TetherPoint x) {
		TetherConfiguration tc = null;

		if (t instanceof SimpleTether) {
			SimpleTether tether = (SimpleTether) t;

			SimpleTetherSegment tetherSegment = (SimpleTetherSegment) tether
					.getTetherSegment(startW, endW);
			tc = new TetherConfiguration(tetherSegment.path.points);

			// Ensure that the tether segment ends at the correct
			// position.
			if (!MathExtended.approxEqual(x.x,
					ListFunctions.getLast(tetherSegment.path.points), 0.0001,
					0.0001)) {
				Log.error("Malformed tether segment.");

				return null;
			}
		} else {
			Log.error("Unsupported tether type.");

			return null;
		}

		return tc;
	}

	/**
	 * Step 5bi (second half) and step 5bii. Computes the shortest paths from a
	 * vertex (obstacle) to the goal.
	 * 
	 * @param source
	 * @param destination
	 * @param visibilityGraph
	 * @param tetherConfiguration
	 * @param maxTetherLength
	 * @param robotRadius
	 * @return
	 */
	private static TetheredAStarShortestPathResult getShortestPaths(
			Point2D source, Point2D destination,
			VisibilityGraph visibilityGraph,
			TetherConfiguration tetherConfiguration, double maxTetherLength,
			double robotRadius) {
		// If the points are equal then return the path with a single node.
		if (source.equals(destination)) {
			Path path = new Path(destination);
			TetherConfiguration tc = new TetherConfiguration(
					tetherConfiguration);
			TetheredAStarSinglePathResult shortestPathResult = new TetheredAStarSinglePathResult(
					path, tc);
			return new TetheredAStarShortestPathResult(shortestPathResult);
		}

		// Create a visibility graph including the source and destination nodes.
		// Note that if either vertex already exists then a new node will not be
		// added, and the existing node will be returned.
		VisibilityGraph g = new VisibilityGraph(visibilityGraph);
		VisibilityGraphNode sourceNode = g.addNode(source);
		VisibilityGraphNode destinationNode = g.addNode(destination);

		// If either the source or destination nodes were not found then fail.
		if (sourceNode == null || destinationNode == null) {
			Log.warning("Source or destination node not found.");

			return null;
		}

		AStarGraph aStarGraph = new AStarGraph(g);

		AStarNode aStarSource = aStarGraph.getNode(sourceNode);
		AStarNode aStarDestination = aStarGraph.getNode(destinationNode);

		boolean pathFound = TetheredAStarPathfinding.getShortestPath(
				aStarGraph, aStarSource, aStarDestination, tetherConfiguration,
				maxTetherLength, robotRadius);

		// Fail if no path was found.
		if (!pathFound) {
			return null;
		}

		return TetheredAStarPathfinding
				.retrieveShortestPathResult(aStarDestination);
	}
	
	private static 

	/**
	 * Generates robot actions given a path.
	 * 
	 * @param path
	 * @param initialRotation
	 * @param rotationalSensitivity
	 * @return robot actions
	 */
	private static List<IRobotAction> generateActionsFromPath(Path path,
			double initialRotation, double rotationalSensitivity) {
		List<IRobotAction> actions = new LinkedList<IRobotAction>();

		// If there is no path to traverse then return an empty actions list.
		if (path.points.size() <= 1) {
			return actions;
		}

		double currentRotation = initialRotation;

		Point2D currentPoint = path.points.get(0);

		for (int i = 1; i < path.points.size(); i++) {
			Point2D nextPoint = path.points.get(i);

			double direction = Math.atan2(
					nextPoint.getY() - currentPoint.getY(), nextPoint.getX()
							- currentPoint.getX());

			double angularChange = MathExtended.getAngularChange(
					currentRotation, direction);

			if (Math.abs(angularChange) >= rotationalSensitivity) {
				RotateAction rotateAction = new RotateAction(angularChange);
				rotateAction.addAction(actions);

				currentRotation = direction;
			}

			MoveAction moveAction = new MoveAction(
					currentPoint.distance(nextPoint));
			moveAction.addAction(actions);

			currentPoint = nextPoint;
		}

		return actions;
	}

}
